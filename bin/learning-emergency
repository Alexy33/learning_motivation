#!/bin/bash

# ============================================================================
# Learning Emergency - Annulation d'urgence des missions et p√©nalit√©s
# ============================================================================

set -euo pipefail

# Configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
readonly CONFIG_DIR="$HOME/.learning_challenge"
readonly LIB_DIR="$SCRIPT_DIR/lib"

# Import des modules
source "$LIB_DIR/config.sh"
source "$LIB_DIR/ui.sh"
source "$LIB_DIR/mission.sh"
source "$LIB_DIR/stats.sh"
source "$LIB_DIR/timer.sh"
source "$LIB_DIR/punishment.sh"

# ============================================================================
# Fonctions principales
# ============================================================================

show_emergency_menu() {
    ui_header "üö® MODE URGENCE"
    ui_warning "Utilisez ces options uniquement en cas de probl√®me grave !"
    echo
    
    local choice
    choice=$(gum choose \
        "üõë Arr√™ter mission actuelle" \
        "üíÄ Stopper toutes les p√©nalit√©s" \
        "üîß R√©initialisation compl√®te" \
        "üìä Voir l'√©tat du syst√®me" \
        "‚ùå Annuler")
    
    case "$choice" in
        "üõë Arr√™ter mission actuelle")
            emergency_stop_mission
            ;;
        "üíÄ Stopper toutes les p√©nalit√©s")
            emergency_stop_punishments
            ;;
        "üîß R√©initialisation compl√®te")
            emergency_full_reset
            ;;
        "üìä Voir l'√©tat du syst√®me")
            emergency_system_status
            ;;
        "‚ùå Annuler")
            ui_info "Op√©ration annul√©e"
            exit 0
            ;;
    esac
}

emergency_stop_mission() {
    ui_header "Arr√™t d'urgence de la mission"
    
    local mission_data
    mission_data=$(config_get_current_mission)
    
    if [[ "$mission_data" == "null" ]] || [[ -z "$mission_data" ]]; then
        ui_info "Aucune mission active √† arr√™ter"
        return 0
    fi
    
    local activity
    activity=$(echo "$mission_data" | jq -r '.activity')
    
    ui_warning "Mission active d√©tect√©e: $activity"
    echo
    
    if ui_confirm "Voulez-vous vraiment arr√™ter cette mission ?"; then
        mission_emergency_cancel
        ui_success "Mission arr√™t√©e avec succ√®s"
    else
        ui_info "Arr√™t annul√©"
    fi
}

emergency_stop_punishments() {
    ui_header "Arr√™t d'urgence des p√©nalit√©s"
    
    punishment_list_active
    echo
    
    punishment_emergency_stop
}

emergency_full_reset() {
    ui_header "üîß R√©initialisation compl√®te"
    ui_warning "ATTENTION: Cette action va:"
    echo "  ‚Ä¢ Arr√™ter toutes les missions"
    echo "  ‚Ä¢ Stopper toutes les p√©nalit√©s"
    echo "  ‚Ä¢ Nettoyer tous les processus"
    echo "  ‚Ä¢ Restaurer les param√®tres syst√®me"
    echo
    ui_error "LES STATISTIQUES SERONT PR√âSERV√âES"
    echo
    
    if ui_confirm "√ätes-vous ABSOLUMENT s√ªr ?"; then
        echo
        ui_info "D√©but de la r√©initialisation..."
        
        # 1. Arr√™ter la mission
        config_clear_mission
        ui_success "‚úì Mission arr√™t√©e"
        
        # 2. Stopper les p√©nalit√©s
        punishment_emergency_stop >/dev/null 2>&1
        ui_success "‚úì P√©nalit√©s stopp√©es"
        
        # 3. Nettoyer les processus
        pkill -f "learning.*timer" 2>/dev/null || true
        pkill -f "punishment" 2>/dev/null || true
        ui_success "‚úì Processus nettoy√©s"
        
        # 4. Nettoyer les fichiers temporaires
        rm -f "$CONFIG_DIR"/timer.pid
        rm -f "$CONFIG_DIR"/current_mission.json
        rm -f "$CONFIG_DIR"/timer_status
        rm -f "$CONFIG_DIR"/notifications.log
        ui_success "‚úì Fichiers temporaires supprim√©s"
        
        echo
        ui_success "üéâ R√©initialisation termin√©e !"
        ui_info "Vous pouvez maintenant relancer 'learning.sh' normalement."
    else
        ui_info "R√©initialisation annul√©e"
    fi
}

emergency_system_status() {
    ui_header "√âtat du syst√®me"
    
    echo
    ui_info "üìÅ Fichiers de configuration :"
    if [[ -f "$CONFIG_DIR/config.json" ]]; then
        echo "  ‚úì config.json pr√©sent"
    else
        echo "  ‚ùå config.json manquant"
    fi
    
    if [[ -f "$CONFIG_DIR/stats.json" ]]; then
        echo "  ‚úì stats.json pr√©sent"
    else
        echo "  ‚ùå stats.json manquant"
    fi
    
    if [[ -f "$CONFIG_DIR/current_mission.json" ]]; then
        echo "  ‚ö†Ô∏è Mission active d√©tect√©e"
    else
        echo "  ‚úì Aucune mission active"
    fi
    
    echo
    ui_info "üîß Processus actifs :"
    local timer_running=false
    local punishment_running=false
    
    if pgrep -f "learning.*timer" >/dev/null 2>&1; then
        echo "  ‚ö†Ô∏è Timer en cours d'ex√©cution"
        timer_running=true
    fi
    
    if pgrep -f "punishment" >/dev/null 2>&1; then
        echo "  ‚ö†Ô∏è P√©nalit√©s actives"
        punishment_running=true
    fi
    
    if [[ "$timer_running" == false && "$punishment_running" == false ]]; then
        echo "  ‚úì Aucun processus actif"
    fi
    
    echo
    ui_info "üíæ Utilisation de l'espace :"
    if [[ -d "$CONFIG_DIR" ]]; then
        local size
        size=$(du -sh "$CONFIG_DIR" 2>/dev/null | cut -f1 || echo "Inconnu")
        echo "  Configuration: $size"
    fi
    
    echo
    ui_info "üîó Commandes disponibles :"
    local commands=("learning-check" "learning-status" "learning-emergency")
    for cmd in "${commands[@]}"; do
        if command -v "$cmd" >/dev/null 2>&1; then
            echo "  ‚úì $cmd disponible"
        else
            echo "  ‚ùå $cmd non trouv√© dans PATH"
        fi
    done
    
    echo
    ui_wait
}

quick_stop() {
    # Arr√™t rapide sans menu (pour usage en script)
    local what=${1:-"all"}
    
    case "$what" in
        "mission")
            config_clear_mission
            echo "Mission arr√™t√©e"
            ;;
        "punishments")
            punishment_emergency_stop >/dev/null 2>&1
            echo "P√©nalit√©s arr√™t√©es"
            ;;
        "all")
            config_clear_mission
            punishment_emergency_stop >/dev/null 2>&1
            pkill -f "learning.*timer" 2>/dev/null || true
            pkill -f "punishment" 2>/dev/null || true
            echo "Tout arr√™t√©"
            ;;
        *)
            echo "Usage: learning-emergency quick [mission|punishments|all]"
            exit 1
            ;;
    esac
}

main() {
    # V√©rifier que la configuration existe
    if [[ ! -d "$CONFIG_DIR" ]]; then
        ui_error "Aucune configuration trouv√©e"
        ui_info "Lancez d'abord 'learning.sh' pour initialiser le syst√®me"
        exit 1
    fi
    
    config_init
    
    # V√©rifier les arguments
    case "${1:-menu}" in
        "menu"|"")
            show_emergency_menu
            ;;
        "quick")
            quick_stop "${2:-all}"
            ;;
        "stop-mission")
            emergency_stop_mission
            ;;
        "stop-punishments")
            emergency_stop_punishments
            ;;
        "reset")
            emergency_full_reset
            ;;
        "status")
            emergency_system_status
            ;;
        "help"|"-h"|"--help")
            cat << EOF
Usage: learning-emergency [action]

Actions:
  menu                 Afficher le menu interactif (d√©faut)
  quick [type]         Arr√™t rapide (mission|punishments|all)
  stop-mission         Arr√™ter seulement la mission
  stop-punishments     Arr√™ter seulement les p√©nalit√©s
  reset               R√©initialisation compl√®te
  status              Voir l'√©tat du syst√®me
  help                Afficher cette aide

Examples:
  learning-emergency              # Menu interactif
  learning-emergency quick        # Tout arr√™ter rapidement
  learning-emergency quick mission # Arr√™ter juste la mission
  learning-emergency status       # Diagnostic syst√®me
EOF
            ;;
        *)
            ui_error "Action inconnue: $1"
            ui_info "Utilisez 'learning-emergency help' pour voir les options"
            exit 1
            ;;
    esac
}

# Point d'entr√©e
main "$@"
